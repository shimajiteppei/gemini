<html>

<body style="margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;">
<div style="display: flex; gap: 12px; padding: 10px; align-items: center; flex-wrap: wrap;">
    <button id="new-game" type="button">New Game</button>
    <button id="pass" type="button">Pass</button>
    <label style="display: inline-flex; gap: 6px; align-items: center;">
        White depth
        <input id="white-depth" type="number" min="1" max="20" step="1" value="6" style="width: 4.5em;" />
    </label>
    <span id="status" style="white-space: pre; font-variant-numeric: tabular-nums;"></span>
</div>

<canvas id="canvas" style="display: block; width: 90vmin; height: 90vmin; touch-action: none;"></canvas>

<script type="module">
    import init, { App } from "./pkg/gemini_wasm.js";

    const OFFSET = 8; // wasm/src/lib.rs の OFFSET と合わせる（CSS px 単位で扱う）

    const canvas = /** @type {HTMLCanvasElement} */ (document.getElementById("canvas"));
    const statusEl = document.getElementById("status");
    const newGameBtn = document.getElementById("new-game");
    const passBtn = document.getElementById("pass");
    const whiteDepthInput = /** @type {HTMLInputElement} */ (document.getElementById("white-depth"));

    /** @type {CanvasRenderingContext2D} */
    const ctx = canvas.getContext("2d");
    if (!ctx) {
        throw new Error("CanvasRenderingContext2D is not available");
    }

    await init();

    /** @type {App} */
    let app;
    let cellSize = 30;
    let needsRedraw = true;

    function newGame() {
        const depth = Math.max(1, Math.min(20, Number.parseInt(whiteDepthInput.value || "6", 10) || 6));
        whiteDepthInput.value = String(depth);
        app = new App(depth);
        needsRedraw = true;
    }

    function resize() {
        const cssSize = Math.floor(Math.min(window.innerWidth, window.innerHeight) * 0.90);
        canvas.style.width = `${cssSize}px`;
        canvas.style.height = `${cssSize}px`;

        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.floor(cssSize * dpr);
        canvas.height = Math.floor(cssSize * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        cellSize = (cssSize - OFFSET * 2) / 8;
        needsRedraw = true;
    }

    function render() {
        app.render(ctx, cellSize);
        statusEl.textContent = app.status_text();
        needsRedraw = false;
    }

    function canvasToBoardXY(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const x = (clientX - rect.left) - OFFSET;
        const y = (clientY - rect.top) - OFFSET;
        const bx = Math.floor(x / cellSize);
        const by = Math.floor(y / cellSize);
        if (bx < 0 || bx >= 8 || by < 0 || by >= 8) return null;
        return { x: bx, y: by };
    }

    canvas.addEventListener("click", (e) => {
        const xy = canvasToBoardXY(e.clientX, e.clientY);
        if (!xy) return;
        if (app.click(xy.x, xy.y)) {
            needsRedraw = true;
            render();
        }
    });

    passBtn.addEventListener("click", () => {
        if (app.pass()) {
            needsRedraw = true;
            render();
        }
    });

    newGameBtn.addEventListener("click", () => {
        newGame();
        render();
    });

    window.addEventListener("resize", () => resize());

    try {
        newGame();
        resize();

        const frame = () => {
            // AI 手番は 0.3 秒遅延させつつ、1 手ずつ進めて都度描画する。
            const done = app.tick_ai(performance.now());
            if (done > 0 || needsRedraw) {
                render();
            } else {
                // 手番が人間でもステータスは更新したい
                statusEl.textContent = app.status_text();
            }
            requestAnimationFrame(frame);
        };
        requestAnimationFrame(frame);
    } catch (err) {
        console.error(err);
        statusEl.textContent = String(err);
    }
</script>
</body>

</html>
