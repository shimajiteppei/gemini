# Design Spec (for Codex): Stronger AlphaBeta AI (Reversi/Othello) in Rust

This document describes **what to implement and how**, in a way that a code generator can follow.
Target project: `gemini_core` (Rust). Keep UI crates untouched unless required.
Focus: improve `alphabeta` AI by adding (1) correctness fixes, (2) iterative deepening + move ordering, (3) transposition table, (4) endgame exact search switch, then (5) better evaluation.

---

## 0. Definitions / Contracts (MUST)

### 0.1 Score convention (IMPORTANT)
All search/eval functions must follow:

- `score(position)` returns a value from the perspective of `position.side_to_move()`.
- Higher score = better for `side_to_move`.
- Negamax recursion uses `-score(child)` convention.

### 0.2 Terminal (game over) convention
Game over = both players have no legal moves (two passes in a row conceptually).

Terminal score should be consistent with 0.1. Recommended:

- `terminal_score = disc_diff_for_side_to_move * DISC_SCALE`
  - `disc_diff_for_side_to_move = my_discs - opp_discs`
  - `DISC_SCALE` can be 1 or something like 100 to dominate heuristics
- Alternatively: return `+SCORE_WIN/-SCORE_WIN` based on disc diff sign, but MUST be:
  - win: `+SCORE_WIN`, lose: `-SCORE_WIN`, draw: `0`

---

## 1. Deliverables (High priority order)

### Deliverable A: Fix terminal score sign + add tests
1. Ensure terminal evaluation follows section 0.
2. Add unit tests for:
   - terminal position: black wins -> score positive when black to move, negative when white to move (or equivalent via side_to_move flips)
   - pass handling: if current has no moves but opponent has -> recursion performs pass correctly

### Deliverable B: Iterative Deepening + Search Limits
Implement iterative deepening driver:
- Search depth increases from 1..=max_depth
- Use a **node budget** first (simpler than wall-clock). Optional later: time limit.
- Always return the best move from the deepest completed iteration.

### Deliverable C: Move Ordering
Implement move ordering to improve alpha-beta pruning:
Priority order:
1. TT best move (if available) first
2. Corner moves first
3. Avoid X/C squares (if corner not owned) (simple heuristic)
4. Others: sort by a cheap heuristic (e.g., mobility delta approximation or static eval after move)

### Deliverable D: Transposition Table (TT)
Implement:
- Zobrist hashing (64-bit)
- TT entries with depth + bound type (EXACT/LOWER/UPPER) + best move
- Probe at node start, store at node end
- Use TT best move for ordering

### Deliverable E: Endgame Exact Search Switch
When `empty_count <= ENDGAME_EMPTY_THRESHOLD`:
- Search to the end (depth = empty_count) and score by exact disc difference (not heuristic)
- Still use alpha-beta + TT (very helpful)

### Deliverable F: Evaluation improvements (after search foundation)
Add phase-dependent weights (empty count based) and at least:
- corner count
- mobility difference
- frontier discs penalty (optional if easy)
Keep it lightweight.

---

## 2. File/Module Plan (Concrete)

### 2.1 New/Updated modules under `gemini_core/src/ai/`
Create (or refactor) within `ai/alphabeta/` OR keep as `ai/alphabeta.rs` with submodules.
Prefer new folder-style module if project style allows. If not, keep all in one file.

Recommended structure:

- `ai/alphabeta/mod.rs` (or `alphabeta.rs`): `Agent` implementing `Ai`
- `ai/alphabeta/search.rs`: iterative deepening + negamax
- `ai/alphabeta/tt.rs`: TT + zobrist
- `ai/alphabeta/move_ordering.rs`: move ordering helpers
- `ai/alphabeta/eval.rs`: evaluation functions
- `ai/alphabeta/limits.rs`: node/time limits and stats

If changing module structure is too risky, implement these as internal structs/functions in `alphabeta.rs`.

---

## 3. Data Structures (Codex-ready)

### 3.1 Search limits and stats
```
rust
pub struct SearchLimits {
pub max_depth: u8,
pub node_budget: u64, // stop when nodes >= budget
// optional: pub time_limit_ms: Option<u64>
}

#[derive(Default, Clone)]
pub struct SearchStats {
pub nodes: u64,
pub cutoffs: u64,
pub tt_hits: u64,
pub tt_stores: u64,
}
```
### 3.2 TT entry
```
rust
#[derive(Copy, Clone)]
pub enum Bound {
Exact,
Lower, // value is a lower bound (fail-high)
Upper, // value is an upper bound (fail-low)
}

#[derive(Copy, Clone)]
pub struct TTEntry {
pub key: u64,           // full key or partial; simplest full key
pub depth: u8,          // remaining depth for which this entry is valid
pub value: i32,
pub bound: Bound,
pub best_move: Option<Square>,
}
```
TT table:
- Use `Vec<Option<TTEntry>>` or `Vec<TTEntry>` with a sentinel `key=0`.
- Index by `key as usize & (size-1)` where `size` is power-of-two.

Replacement:
- Always replace, OR replace only if new depth >= old depth.

### 3.3 Zobrist
```
rust
pub struct Zobrist {
pub black: [u64; 64],
pub white: [u64; 64],
pub side_to_move: u64,
}
```
- Fill with deterministic pseudo-random numbers (e.g., splitmix64 from a fixed seed).
- Hash compute:
  - XOR all occupied squares for black/white
  - XOR `side_to_move` if black-to-move (or white-to-move), choose one convention.

Optimization (optional later):
- Store hash in `Position` and update incrementally. Initial version can recompute.

---

## 4. Search Algorithm (Exact behavior)

### 4.1 Public API called by `Agent::select_move`
Implement:
1. Generate legal moves. If none -> `Pass`.
2. Run `iterative_deepening(position, limits, tt)`:
   - For depth in 1..=limits.max_depth:
     - call `root_search(position, depth, ...)` returning `(best_move, best_score)`
     - if aborted due to node budget, break and return last completed best_move
3. Return best_move.

### 4.2 Node budget stopping
At start of each `negamax`:
- `stats.nodes += 1`
- if `stats.nodes >= limits.node_budget` => return an "abort" to unwind.
Implementation choices:
- Return `Result<i32, SearchAbort>`
- Or return `(i32, bool aborted)`
Codex should implement with `Result` for clarity.

Define:
```
rust
pub struct SearchAbort;
```
### 4.3 Negamax with alpha-beta and TT
Signature:
```
rust
fn negamax(
pos: Position,
depth: u8,
mut alpha: i32,
beta: i32,
ctx: &mut SearchContext
) -> Result<i32, SearchAbort>
```
Context includes:
```
rust
pub struct SearchContext<'a> {
pub limits: SearchLimits,
pub stats: SearchStats,
pub tt: &'a mut TranspositionTable,
pub zobrist: &'a Zobrist,
}
```
Algorithm steps inside `negamax`:

1. Node budget check.
2. Compute key = hash(pos).
3. TT probe:
   - If entry matches key and entry.depth >= depth:
     - if bound == Exact => return entry.value
     - if Lower => alpha = max(alpha, entry.value)
     - if Upper => alpha window shrink via beta? (specifically: beta = min(beta, entry.value) if using mutable beta; easiest: handle as:
       - if entry.bound == Upper and entry.value <= alpha -> return entry.value
       - if entry.bound == Lower and entry.value >= beta -> return entry.value
       - else continue with adjusted alpha/beta
     - If alpha >= beta => cutoff return entry.value
4. Terminal / depth end:
   - If depth == 0 => return evaluate(pos) (or exact endgame if enabled; see 4.5)
5. Generate legal moves:
   - If none:
     - If opponent also none => return terminal_eval(pos)
     - Else => return `-negamax(pos.pass(), depth-1, -beta, -alpha)`
6. Order moves using `order_moves(pos, legal_moves_bitboard, tt_best_move, phase)`
7. Loop moves:
   - child = pos.apply_move(move)
   - score = -negamax(child, depth-1, -beta, -alpha)
   - best = max(best, score)
   - alpha = max(alpha, best)
   - if alpha >= beta => cutoff; stats.cutoffs += 1; break
8. Store TT:
   - Determine bound type:
     - if best <= alpha_orig => Upper
     - else if best >= beta => Lower
     - else Exact
   - Store best_move too.
9. Return best.

NOTE: Keep `alpha_orig` (initial alpha) to compute bound.

### 4.4 Root search specifics
Root search returns best move and score.
At root, set:
- alpha=-INF, beta=+INF
- Iterate ordered moves, track best_move.

### 4.5 Endgame exact mode
Define:
- `ENDGAME_EMPTY_THRESHOLD: u8` (e.g., 14)

At node start:
- compute `empty = pos.empty_count()` (or `64 - (black|white).count_ones()`)
- if `empty <= ENDGAME_EMPTY_THRESHOLD`:
  - treat evaluation as exact by searching to terminal:
    - effective depth = min(depth, empty) but for exact mode you want depth = empty
  - At depth==0 in exact mode, DO NOT call heuristic. Instead:
    - If game over -> terminal exact disc diff
    - Otherwise continue (so prefer “set depth = empty at root” rather than mixing)

Simpler implementation:
- In iterative deepening driver:
  - if empty <= threshold: call a separate function `endgame_root_search(pos, empty, ...)` that searches to the end and ignores max_depth.

---

## 5. Move Ordering (Concrete rules)

Function:
```
rust
fn order_moves(
pos: &Position,
legal: u64,
tt_move: Option<Square>,
) -> SmallVec<[Square; 32]>
```
Rules:
1. Convert legal bitboard to a Vec/SV of squares.
2. Score each move with integer priority:
   - if move == tt_move => +1_000_000
   - if move is corner => +100_000
   - if move is X-square (diagonal adjacent to corner) and that corner is empty/not owned => -50_000
   - if move is C-square (edge adjacent to corner) and that corner is empty/not owned => -20_000
   - else 0
3. Sort descending by score (stable sort OK).

Note: Keep it deterministic.

---

## 6. Evaluation (Minimal, Phase-weighted)

Phase:
- `empty = empty_count() as i32`
- Define 3 phases by empty:
  - opening: empty > 44
  - mid: 20 < empty <= 44
  - end: empty <= 20 (not the exact endgame solver; just heuristic phase)

Heuristic terms:
- `corner_diff = my_corners - opp_corners`
- `mobility_diff = my_legal_moves - opp_legal_moves`
- `material_diff = my_discs - opp_discs` (weight small except late)

Weights example:
- opening: corners=30, mobility=5, material=0
- mid: corners=30, mobility=3, material=1
- end: corners=20, mobility=1, material=5

Eval must be from side_to_move perspective.

---

## 7. Benchmarks / Tests (What to add)

### 7.1 Unit tests
- Terminal score sign test
- Pass move behavior test
- TT smoke test: same position searched twice => tt_hits increases (if stats exposed)

### 7.2 Bench
- Bench a fixed midgame position:
  - run `depth=6` with and without TT (feature flag or config) and compare nodes/time
- Ensure deterministic output

---

## 8. Implementation Steps (Codex execution plan)

Step 1: Correctness
- Fix terminal evaluation convention.
- Add tests for terminal and pass.

Step 2: Refactor search into `iterative_deepening + negamax`
- Add `SearchLimits`, `SearchStats`, node budget abort.
- Keep move ordering simple (corner first).

Step 3: Add TT + Zobrist
- Implement zobrist generator (splitmix64).
- Add TT probe/store with bound logic.
- Use TT best move for ordering.

Step 4: Improve move ordering
- Add X/C square penalties.
- Keep corner priority.

Step 5: Endgame exact mode
- Add empty count function usage.
- If empty <= threshold: search to end, return exact disc diff.

Step 6: Evaluation improvements
- Add phase weights (empty-based).
- Keep weights constants.

After each step:
- run `cargo test`
- run `cargo clippy --workspace --all-targets --all-features`
- ensure formatting is rustfmt clean

---

## 9. Non-goals (Do NOT do in this iteration)
- Parallel search
- Opening book
- NNet evaluation
- Unsafe code micro-optimizations
- Large pattern databases (edge patterns) (too big for initial upgrade)

---
End of spec.
